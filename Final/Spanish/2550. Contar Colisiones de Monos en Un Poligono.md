
Existe un polígono convexo regular con `n` vértices. Los vértices están etiquetados del `0` al `n - 1` en dirección horaria, y cada vértice tiene **exactamente un mono**. La siguiente figura muestra un polígono convexo de `6` vértices.

![](https://assets.leetcode.com/uploads/2023/01/22/hexagon.jpg)

Cada mono se mueve simultáneamente a un vértice vecino. Un vértice vecino para un vértice `i` puede ser:

- el vértice `(i + 1) % n` en la dirección horaria, o
- el vértice `(i - 1 + n) % n` en la dirección antihoraria.

Una **colisión** ocurre si al menos dos monos residen en el mismo vértice después del movimiento o se intersectan en un borde.

Devuelve _el número de formas en que los monos pueden moverse de modo que ocurra al menos **una colisión**_. Dado que la respuesta puede ser muy grande, devuélvela módulo `10^9 + 7`.

**Notar** que cada mono solo puede moverse una vez.

**Ejemplo 1:**

**Entrada:** n = 3
**Salida:** 6
**Explicación:** Hay 8 movimientos posibles en total.
Dos formas en que colisionan en algún punto son:
- El mono 1 se mueve en dirección horaria; el mono 2 se mueve en dirección antihoraria; el mono 3 se mueve en dirección horaria. Los monos 1 y 2 colisionan.
- El mono 1 se mueve en dirección antihoraria; el mono 2 se mueve en dirección antihoraria; el mono 3 se mueve en dirección horaria. Los monos 1 y 3 colisionan.
Se puede demostrar que 6 movimientos totales resultan en una colisión.

**Ejemplo 2:**
**Entrada:** n = 4
**Salida:** 14
**Explicación:** Se puede demostrar que hay 14 formas para que los monos colisionen.

**Restricciones:**
- `3 <= n <= 10^9`
## Pensamientos Iniciales

Recuerdo que al principio, cuando empecé a enfrentar los problemas de LeetCode, hacía juicios basados en mi habilidad de que algo era más difícil de lo que parecía. Y con problemas que tenían diagramas como este, muchas veces terminaba diciendo "Ay Dios mío". Pero una vez que superas eso y realmente juzgas un problema por lo que es, vas a descubrir que muchos problemas verbosos son en realidad bastante simples, y muchos otros son totalmente lo contrario jaja.

El contexto en el que se discute el problema son básicamente los grafos. Hablan de ejes y vértices.

Noté desde el principio que puedes visualizar esto como una cadena binaria, donde cada posición en la cadena puede tomar un 1 o un 0.

Cada uno de los monos puede hacer un movimiento. Pueden ir hacia la izquierda o hacia la derecha, o podemos pensar que pueden ir 1 o pueden ir 0. Tiene que haber una decisión para cada mono. Entonces, el total absoluto posible de combinaciones de movimientos de los monos en un polígono de n-vértices será el total de combinaciones que obtienes con n posiciones en la cadena binaria.

Como hay n posiciones y cada una de las posiciones puede tomar dos valores, ya sea un 1 o un 0, básicamente tienes **2<sup>n</sup>** combinaciones.

Ahora el problema se convierte (que de hecho era la única pista que tenía este problema) en contar las combinaciones que no producen colisiones para restarlas de ese valor de combinaciones posibles totales de movimientos que ahora sé que es **2<sup>n</sup>**.

## Experiencias Pasadas

Vértices y ejes/aristas son la nomenclatura básica con la que uno se encuentra en problemas que hacen uso de grafos de cualquier tipo. Pero también, curiosamente, puedo relacionar esto incluso con la matemática o geometría de la primaria, donde se habla de vértices y aristas. Todo termina conectándose de una manera u otra.

Existen muchos problemas que hacen pensar en ejes y vértices. Recuerdo haber estado a menudo confundido acerca de lo que querían decir con vértices y ejes, confundiéndolos uno con el otro. Pero ahora comprendo bastante rápido de qué hablan mientras leo. Supongo que la comprensión lectora en cuanto a ese tipo de contexto y vocabulario ha mejorado.

Y sí, hay muchos problemas sobre eso. Así que si al principio uno se siente algo lento con ellos o con su nomenclatura, hay que seguir esforzándose; no es que se vuelvan más fáciles, sino que uno se vuelve más hábil.

También hay muchos problemas sobre tener que acorralar o enumerar posibilidades. De hecho, hay una etiqueta literalmente de 'Enumeración' donde uno tiene que descubrir y listar cada uno de los casos límite del problema y decidir cómo manejarlos explícitamente.

En este caso es conceptualmente algo similar porque uno descubre que cada mono puede moverse en una dirección u otra en un paso. No pueden ir más allá de una vez. Así que esas opciones de movimientos son los casos que enumeramos, contabilizamos y manejamos en nuestro código. Entonces tenemos que pensar en las posibles combinaciones de eso.

Si no es solo un mono, sino dos, tres o cuatro, y el número de monos depende del número de vértices en el polígono y cada uno tiene la capacidad de tomar una decisión u otra, todo eso hace un conjunto de combinaciones de decisiones finales teniendo en cuenta lo que decide cada mono.

En resumen, enfrentando problemas en LeetCode he encontrado cuestiones tanto de grafos, como de cosas que tienen que ver con la enumeración y explícitamente con material binario: cadenas binarias y manipulación de bits, entre otros comunes. El primero incluso si son solo problemas geométricos sencillos como este o problemas complejos en los que aún se debe pensar de manera abstracta sobre grafos y aristas mientras se trabaja con arreglos.

Y el segundo para un rango más amplio y variado de casos.

## Interacción con ChatGPT

Esta vez no usé ChatGPT. Ni en esta ocasión, ni cuando me enfrenté al problema por primera vez en abril.

De hecho, empecé a usarlo más intensamente justo después de esto cuando compré GPT-Plus y decidí usarlo como instructor.

Pero esta segunda vez que abordé este problema, definitivamente puedo ver cómo mis discusiones con él sobre Manipulación de Bits, Enumeración y Grafos, particularmente el vocabulario alrededor de los grafos, han facilitado notablemente la dificultad de leer los enunciados de los problemas. Y filtrando las posibles soluciones.

De hecho, me encuentro haciendo menos suposiciones inapropiadas. Y esto no solo ocurre con problemas que ya he visto. Todavía encuentro, con nuevos problemas que enfrento, que tengo un conjunto de posibilidades más estrecho y más enfocado de suposiciones para hacer sobre ellos, y que cada vez es más probable que estén en lo cierto.

Así que encuentro que mis suposiciones, en primer lugar, son cada vez más precisas. Y creo que se debe en gran medida a cómo ChatGPT y yo hemos interactuado en el contexto de resolver otros problemas variando en temas y dificultad en LeetCode con este enfoque de alto nivel primero.

## Descubrimientos

Al revisar este problema, habiéndome enfrentado a él antes, es difícil decir si llegué a una solución por mí mismo justo ahora.

Quiero decir, probablemente cualquier resto de memoria a corto plazo que haya quedado de la primera vez que lo vi ya se ha borrado lo suficiente, pero quizás, en lo profundo de la parte de memoria a largo plazo de mi cerebro, todavía pueda haber algún patrón establecido solo desde esa vez que sufrí en frustración tratando de encontrar una solución al problema.

Pienso en esto, porque esta vez realmente encontré que la solución era super directa.

Lo que quiero decir es, sé que ahora tengo más perspectivas sobre cómo verificar que la suposición que hice sobre la solución correcta es correcta, pero es difícil saber si hacer esa suposición correcta fue directamente influenciada por haber encontrado y recordado de alguna manera los patrones en la solución la primera vez.

En cualquier caso, hubo un gran momento de realización cuando entendí, primero que todo, lo que expliqué antes sobre entender esto como Cadenas Binarias: las combinaciones de decisiones que son posibles para que todos los monos tomen. La segunda fue descubrir que, como la gran mayoría de las combinaciones producirían colisiones, tenía que preocuparme por contar las que no producen colisiones.

Y eso hice, y descubrí que la única forma de no tener colisiones, ni en vértices ni en aristas, es que todos los monos se muevan en la misma dirección, que puede ser en el sentido de las agujas del reloj o al contrario.

Lo que significa restar 2 del total de combinaciones posibles de decisiones que ellos pueden tomar.

## Solution

```Python
class Solution:
    def monkeyMove(self, n: int) -> int:
        mod = 10 ** 9 + 7
        return (pow(2, n, mod) - 2) % mod
```

## Tricky parts

Remember how I just talked about how sometimes rather verbose problems would be super easy and the other way around? well, that's basically what I just got into trying to understand in depth what we need to be doing with the modular operation.

And we don't need to go so far back. The only thing that we need to know is that if we have a set of numbers that we want to evaluate and the result after the evaluation is going to be super big, one way we can set a boundary for what those values can be is using the modulus operation.

Basically if you apply modulus to any value, you force the result to be inside a range from zero to the value you are applying the mod with `[0, mod]`, which makes all the results of doing modulo on some number non-negative and up until modulo, including it. And if you evaluate over modulo a number that's bigger than that, it's going to give you a result that is in that range.

So the modulo operation is a lot of times, including this one, used to make values fit into a range.

And in the case of our problem, it effectively gives us a bound for values that could be huge. In this case, we can't directly calculate 2<sup>n</sup> and then just subtract 2 from it because n could be super huge, and the result even bigger.

Or it can also be small and when we substract 2 from it could make it negative, so applying module again brings it back to somewhere in `[0, mod]`.

And if I remember correctly, all of those modular arithmetic considerations for optimization are intrinsic to the way the pow function in Python works.

## Optimization

This is of the type of LeetCode problems that on the way to the only test-passing solution you optimize most of it. The runtime rankings are pretty tight and would through my code answer around the whole percentile spectrums.

So in summary, we know pow is optimized to get the power of a number like crazy, and us handling the mod to get to the solution makes us use it optimally.

## What I learned

Returning solutions modulo a number is a fairly common pattern. Particularly in competitive programming questions of this type just by the nature of such high number returning problems and us wanting to give boundary to them. Both on the problem statement design and coming up with a solution ends.

The question has a tag recursion that I barely see how applies. I guess there could be another way to solve the problem that uses it, maybe to generate and count combinations but the Math solution gives a more straightforward approach.

In my experience, modular arithmetic in general has a wide range of applications and in a lot of problems they are touched upon but as secondary to the main topics of a question. So to a great degree is one of topics not tagged on LeetCode but still basic and assumed to have some familiarity with.

## Further

[ChatGPT](https://chat.openai.com/share/b2ada5c5-145e-4a2e-9bfd-db562f541321) got me in touch with the rabbit hole of modular arithmetic I could get into if I wanted. But I got out once I had more clarity on the nature of using module, how to use it, and why they commonly use it on some problem questions. Also the value `10**9 + 7` in relation to that.

Another common pattern is finding solution post from user lee215 and so I did review [his](https://leetcode.com/problems/count-collisions-of-monkeys-on-a-polygon/solutions/3111664/java-c-python-should-be-pow-2-n-4/) this time to get some insight and curious of if there were further improvements which could be made to the solution I came up with.
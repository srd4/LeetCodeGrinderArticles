
Este es el cuarto de una serie de artículos que he estado escribiendo para documentar experiencias dominando estructuras de datos y algoritmos como programador autodidacta para que otros puedan obtener comprensión, guía y motivación.

Hoy tenemos un problema con tags 'String', 'Dynamic Programming', y 'Prefix sum' que dice así:

Hay una cadena binaria `floor` indexada a 0, que representa los colores de las baldosas de un piso:

- `floor[i] = '0'` significa que la `i-ésima` baldosa del suelo es de color **negro**.
- Por otro lado, `floor[i] = '1'` significa que la `i-ésima` baldosa del suelo es de color **blanco**.

También tenemos `numCarpets` y `carpetLen`. Y hay `numCarpets` alfombras negras, cada una de `carpetLen` baldosas. Hay que cubrir las baldosas con las alfombras de forma que el número de baldosas blancas aún visibles sea mínimo. Las alfombras pueden cubrirse las unas a las otras.

El objetivo de devolver el número mínimo de baldosas blancas aún visibles.

**Ejemplo 1:**
![[Pasted image 20231101102850.png]]
**Input:** floor = "10110101", numCarpets = 2, carpetLen = 2
**Output:** 2
**Explicación**: 

La figura anterior muestra una forma de cubrir las baldosas con las alfombras de forma que sólo queden visibles 2 baldosas blancas.

Ninguna otra forma de cubrir las baldosas con las alfombras puede dejar menos de 2 baldosas blancas visibles.

**Ejemplo 2:**
![[Pasted image 20231101103121.png]]
**Input:** floor = "11111", numCarpets = 2, carpetLen = 3
**Output:** 0
**Explicación:** 

La figura anterior muestra una forma de cubrir las baldosas con las alfombras de forma que no se vean baldosas blancas.

Hay que observar que las alfombras pueden solaparse unas con otras.

**Limitaciones:**

- `1 <= carpetLen <= floor.lenght <= 1000`
- `floor[i]` es `'0'` o `'1'`.
- `1 <= numCarpets <= 1000`
## Pensamientos iniciales

Parece que inicialmente, tanto yo como otros, consideramos un enfoque greedy para optimizar la colocación de alfombras con el fin de cubrir la mayor cantidad de baldosas blancas en cada paso. 

Sin embargo, con contraejemplos, quedó claro que este enfoque no proporcionaba la solución óptima. Según la sección de soluciones, parecía más bien necesario encontrar la solución óptima en cada momento y sumarlas para obtener el mínimo número posible de baldosas blancas visibles al final.

Mi primer enfoque la primera vez que me encontré con este problema hace 6 meses probablemente fue manipulando arreglos de alguna manera. Al intentar el enfoque greedy esta segunda vez y encontrar un par de contraejemplos, lo descarté rápidamente.

Fue algo interesante ver este tipo de problema por primera vez. Etiquetado como 'difícil', la dificultad era un poco intimidante.

Si recuerdo bien, probablemente fue la primera vez que vi el uso de diagramas para explicar el enunciado del problema.

## Experiencias pasadas

He encontrado problemas o temas similares relacionados con la programación dinámica antes, pero probablemente este sea el primero de su tipo que he abordado. El concepto a menudo se siente confuso, especialmente en torno a la precomputación de valores para ser reutilizados más tarde. Entender las soluciones es complejo por sí mismo, pero idear las mías puede sentirse, y todavía hasta el día de hoy se siente, aún más complicado.

He visto problemas similares con tag String y Prefix Sum. El problema me hizo recordar este último concepto y el artículo de [Wikipedia](https://es.wikipedia.org/wiki/Suma_prefija) con el que lo entendí por primera vez.

El enfoque de programación dinámica que se requiere aquí mantiene una suma de las baldosas blancas visibles restantes en un arreglo bidimensional en cada posición, lo cual es un poco reminiscente de problemas con suma de prefijos que he encontrado anteriormente.


## Interacción con ChatGPT

Con ChatGPT generalmente sigo un par de patrones de peticiones para buscar explicaciones de tags y entender soluciones complejas en LeetCode, muchas veces provenientes de usuarios recurrentes de LeetCode como Lee215, cuyo inglés puede ser difícil de leer, pero soluciones son precisas. Encuentro útil a ChatGPT para elaborar sobre esas soluciones, explicando la lógica y el código involucrado de una manera estructurada, para mejorar la comprensión.

![Conversación con ChatGPT sobre solución de DP](Static/chatgpt_prompt_dpsolution.png)

Prefiero pedir a ChatGPT que aclare soluciones existentes hechas por humanos en lugar de pedirle que proporcione nuevas él mismo, ya que a veces puede alucinar u ofrecer soluciones menos óptimas.

Inicialmente, pensé que un enfoque greedy podría funcionar, pero pronto me di cuenta de que llevaba a soluciones subóptimas.

A través de interacciones y revisión de diferentes submissions, exploré soluciones con diferentes enfoques a la programación dinámica, aprendiendo más sobre estrategias de abajo hacia arriba y de arriba hacia abajo, y a cuándo usar la programación dinámica.

No pude hacerle todas mis preguntas debido a limitaciones de tiempo. El problema es significativamente más difícil de procesar que otros sobre los que he escrito y enfrentado antes, y en tales casos, la señal para seguir adelante en mi método se testea.

En mi experiencia, cuanto más rápido me alejo de la frustración, mientras la busco activamente a través de hacer y probar suposiciones, más rápido aprendo.

También me pregunté si el problema podría abordarse como un escenario de ventana deslizante (sliding window), considerando el índice de inicio de cada alfombra en lugar de una colocación greedy. Inicialmente, seguí un camino equivocado basado en esta idea. Esto evolucionó al descubrir un ejemplo crucial en la sección de discusión y el descrubrimiento de lo mismo de mi parte en aislamiento, llevándome a entender que el problema tenía un espacio de búsqueda más grande con más posibilidades para combinaciones de colocación de alfombras.

También utilicé ChatGPT para ajustar una solución más profunda en comparación con la solución sucinta y pythonica de Lee215.

## Partes complicadas

Como dije, fue complicado descubrir cómo recorrer el espacio de combinaciones para la colocación de las alfombras. La programación dinámica (DP) siempre es un poco desalentadora por su dificultad para entender, y en mi caso a menudo sucede que no se me viene a la mente de manera intuitiva una solución.

Aunque no había ninguna limitación complicada, entender el enfoque de DP y la subestructura óptima del problema seguía siendo un desafío. El objetivo es minimizar algo encontrando mínimos en subsecuencias, lo cual en general es difícil de visualizar.

Con más aprendizaje y una mirada más cercana, podría mejorar en esto, pero todavía no me siento fuerte en este tema y por esa razón todavía no he podido marcarlo como entendido en mi base de datos.


## Solution


```python
class Solution:
    def minimumWhiteTiles(self, floor, k, l):

        @lru_cache(None)
        def dp(i, k):
            if i <= 0: return 0
            return min(int(floor[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)
            
        return dp(len(floor), k) 

```

As mentioned, the solution revolves around a DP approach to minimize the number of visible white tiles after placing a given number of carpets on a floor represented by the string `floor`. The core of this solution is the `dp` function, which is memoized using `lru_cache` to improve performance by storing the results of previous computations -that's what memoization means.

The `dp` function takes two arguments: `i`, the current index in the string representing the `floor`, and `k`, the number of carpets left to lay. The function is called recursively, working from right to left across the string, considering two main choices at each step: placing a carpet or not:

1.  **Not Placing a Carpet:** If a carpet isn't placed at the current index, the function adds `1` to the count if a white tile is present (`int(A[i - 1])` converts the character at the current index to an integer, adding `1` if it's a white tile), and then `dp` calls itself recursively with `i - 1`, moving one step to the left, keeping the count of carpets `k`  left to place unchanged.

2. **Placing a Carpet:** If a carpet is placed, the function calls itself also with `i - l`, jumping by the length of a carpet (we skip `l` positions because a carpet is there), and `k - 1`, reducing the count of remaining carpets by `1`. However, this choice is only considered if there are carpets left to place (`k` is not zero), otherwise, a large value (`1000`) is used to represent an undesirable choice, effectively ignoring this option, and always going for the other side of `min`. 

The recursion continues until the left end of the string is reached (`i <= 0`), at which point `0` is returned, serving as the base case to terminate the recursion.

The main method initiates the dynamic programming process by calling `dp` with the initial index set to the length of the string `floor`, and the initial count of carpets `k`, and returns the result, representing the minimum number of visible white tiles after placing all carpets optimally.

## Optimization

Just understanding the actual complexity as described by these guys was initially challenging. With dynamic programming, it seems like the states are built around the indexes or tiles and the number of carpets `k`. So, the states are essentially what happens at a particular index after placing a certain number of carpets.

The complexity arises as we consider all positions from 0 to n (length of `floor`) and all carpet counts from 0 to k, leading to n times k states.

There are weird scenarios, like stacking a bunch of carpets at index 0, which feels illogical and calls for optimization to eliminate such considerations. These states seemed to inflate the space complexity and possibly the time complexity too.

## Learned

This problem dives into the core of dynamic programming and gave me an opportunity to work on its fundamental concepts. I got to grasp, perhaps to an intermediate extent, the essence of recursiveness, tabulation, and memoization, and how the same ideas can be implemented with iterative rather than recursive code, essentially tabulating states.

I got a little bit of an initial handle on optimally solving problems, understanding how tackling larger problems with optimal solutions to smaller sub-problems aligns with dynamic programming.

I was able to expose the inadequacy of a greedy approach, affirming that dynamic programming, is the suitable strategy for such problems that are optimal in structure. I think this was the most significant realization of the session.

## Further

The resources I used were basically the [convo with ChatGPT](https://chat.openai.com/share/f2df59ac-f8e5-4a2e-85fe-2b41ab8f9615) on this topic that I had today and yesterday. And the couple solutions ([first](https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/solutions/1863955/java-c-python-dp-solution/) and [second](https://leetcode.com/problems/minimum-white-tiles-after-covering-with-carpets/solutions/1872882/python-readable-and-easy-understand-bottom-up-dp-solution-in-python/))from users on LeetCode I feed as context to ChatGPT and drew understanding from.

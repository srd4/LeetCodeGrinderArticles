
## Initial thoughts 

Initially me and  others on the discussion and solutions sections, considered a greedy approach to optimize the placement of carpets to cover the most white tiles at each step. However, it became clear that the greedy approach didn't yield the optimal solution. It was rather necessary to find the optimal solution at each step and sum those together to get the total optimal, or minimal in this case.

My first thought the first time I encountered this problem was likely about manipulating arrays somehow. Trying the greedy approach this second time and finding a couple counter examples, I discarded it. It was kind of interesting to see this kind of problem the first time around. The difficulty a bit intimidating. And this was probably the first time I saw the use of diagrams to explain the problem statement.

## Past experiences

I've come across similar problems or topics related to dynamic programming before, but this is likely the first of its kind I tackled. The concept often feels confusing, especially around the pre-computation of values to be reused later. Understanding solutions is one thing, but devising my own can and still do feel hellish. I've seen similar problems with the tag strings and prefix sum, which is just another term for cumulative sum, made me recall the concept.

The dynamic programming approach required here keeps a sum of the remaining visible white tiles in a two-dimensional array, which is a bit reminiscent of problems with prefix sum I've encountered before.

## ChatGPT interaction

With ChatGPT I usually follow a couple prompting patterns for seeking tag explanations and understanding tricky solutions on LeetCode, often times from specific recurrent users like Lee215 whose English may be hard to understand but solutions are spot on. I find ChatGPT useful in elaborating on those solutions, explaining the logic and code involved in a structured manner, to enhance understanding.

I prefer to ask ChatGPT to clarify existing human made solutions rather than asking it to provide new ones himself, as it can sometimes hallucinate or offer less optimal solutions.

For the problem, initially, I thought a greedy approach might work but soon realized it led to suboptimal solutions. Through interactions and reviewing different solutions, I explored solutions with different approaches to dynamic programming, learning more about bottom-up and top-down strategies, and when to use dynamic programming. However, I didn't get to ask all my questions due to time constraints.

I also wondered if the problem could be approached as a sliding window scenario, considering each carpet's starting index rather than a greedy placement. Initially, I pursued a wrong route based on this insight. This evolved through discovering a crucial example in the discussion section and self-discovery in isolation, leading me to understand that the problem had a larger search space with more possibilities for carpet placements. I tweaked around a more in-depth second solution compared to Lee215's succinct, Pythonic solution.

## Tricky parts

It was tricky figuring out how to traverse the space of carpet placement combinations. Dynamic programming (DP) is always a bit daunting and it doesn't intuitively come to mind as a solution. Although there weren't any coding constraints, understanding the DP approach and the problem's optimal substructure was challenging still. The goal is to minimize something by finding minima in sub-sequences, which was hard to visualize.

With more learning and a closer look, I might get better at it, but I still don't feel strong on this one and haven't marked it as understood on my database yet.

## Solution


```python
class Solution:
    def minimumWhiteTiles(self, floor, k, l):

        @lru_cache(None)
        def dp(i, k):
            if i <= 0: return 0
            return min(int(floor[i - 1]) + dp(i - 1, k), dp(i - l, k - 1) if k else 1000)
            
        return dp(len(floor), k) 

```

As mentioned, the solution revolves around a DP approach to minimize the number of visible white tiles after placing a given number of carpets on a floor represented by the string `floor`. The core of this solution is the `dp` function, which is memoized using `lru_cache` to improve performance by storing the results of previous computations.

The `dp` function takes two arguments: `i`, the current index in the string representing the `floor`, and `k`, the number of carpets left to lay. The function is called recursively, working from right to left across the string, considering two main choices at each step: placing a carpet or not.

1.  **Not Placing a Carpet:** If a carpet isn't placed at the current index, the function adds `1` to the count if a white tile is present (`int(A[i - 1])` converts the character at the current index to an integer, adding `1` if it's a white tile), and then `dp` calls itself recursively with `i - 1`, moving one step to the left, keeping the count of carpets `k`  left to place unchanged.

2. **Placing a Carpet:** If a carpet is placed, the function calls itself also with `i - l`, jumping by the length of a carpet (we skip `l` positions because a carpet is there), and `k - 1`, reducing the count of remaining carpets by `1`. However, this choice is only considered if there are carpets left to place (`k` is not zero), otherwise, a large value (`1000`) is used to represent an undesirable choice, effectively ignoring this option.  

The recursion continues until the left end of the string is reached (`i <= 0`), at which point `0` is returned, serving as the base case to terminate the recursion.

The main method initiates the dynamic programming process by calling `dp` with the initial index set to the length of the string `floor`, and the initial count of carpets `k`, and returns the result, representing the minimum number of visible white tiles after placing all carpets optimally.

## Optimization

Just understanding the actual complexity as described by these guys was initially challenging. With dynamic programming, it seems like the states are built around the indexes or tiles and the number of carpets `k`. So, the states are essentially what happens at a particular index after placing a certain number of carpets.

The complexity arises as we consider all positions from 0 to n (length of `floor`) and all carpet counts from 0 to k, leading to n times k states.

There are odd scenarios, like stacking a bunch carpets at index 0, which feels illogical and calls for optimization to eliminate such considerations. These states seemed to inflate the space complexity and possibly the time complexity too.

## Learned

This problem dives into the core of dynamic programming and gave me an opportunity to work on its fundamental concepts. I got to grasp, perhaps to an intermediate extent, the essence of recursiveness, tabulation, and memoization, and how the same ideas can be implemented with iterative rather than recursive code, essentially tabulating states.

I got a little bit of an initial handle on optimally solving problems, understanding how tackling larger problems with optimal solutions to smaller sub-problems aligns with dynamic programming.

I was able to expose the inadequacy of a greedy approach, affirming that dynamic programming, not greed, is the suitable strategy for such problems. This was a significant realization in my attempt to understand the broader spectrum of data structures and algorithms through this problem.


Further - Are there any resources, readings, or tools that you found particularly helpful or 
enlightening for this problem?

I guess the two solutions that I evaluated. I checked the hints and lit code a little bit, and the conversation that I had with ChatGPT that I was due to expand on, but I'm not tempted to use more of my time stuck understanding at a low level this question. I can give it a little bit of a break before delving more into these topics, but it's clear that dynamic programming is one of those topics that I have to pay more attention to because it is still challenging.

Initial thoughts - What methods or algorithms came to mind when you first approached this problem?

The first time that I did it, I was probably thinking like another user on the discussion section. And actually, many others in the solutions section thought about a greedy approach for finding at each step optimizing for basically the best position to place a carpet in in terms of how many white tiles it covered. But it turns out an optimal solution, it turns out the greedy solution doesn't make up the optimal solution. You basically have to find the optimal solution at each one of the stages to be able to minimize your little thing. And so, yeah, I think I considered a greedy approach this time. The first time, though, I think I probably was thinking about, I don't even remember what the first encounter with this was. But I do remember the problem statement and the tiles problem was particularly interesting. I guess because it was the first that used these kind of elaborated diagrams to show what the problem statement was about. Well, they're not super elaborated, but they're diagrams, yeah. And so, no, I just was thinking about manipulating arrays the first time. The second time I tried the greedy thing, but I quickly discovered it didn't hold for the second example, so I ruled it out.

Past experiences - Are there related problems or topics you've encountered that share similarities with this one?

[12:17 PM, 10/24/2023] Daniel Gil: Are there related problems or topics you've encountered that share similarities with this one? I think I have, this is probably the first that I ever did, but I have confronted dynamic programming problems before. And so, in that regard, yes, and it actually continues to be kind of confusing in a way. We know that it's like pre-computing a lot of times, pre-computing values that are going to be reused at some point or immediately next in this case. But it's like kind of hellish to, I can understand solutions, but it's difficult to figure out how to come up with a solution like that. So, yeah, I have found problems that are similar in many ways that deal with strings. And another tag that the question has is prefix sum, and I have encountered problems that have that tag.

[12:18 PM, 10/24/2023] Daniel Gil: This is interesting because it's one of those times where the naming makes it difficult to remember. This is just cumulative sum, which is the thing that I remember the sums as being. And, yeah, in some sort of way you kind of use it. And, yeah, actually what is being held on each one of the cells of the dynamic programming two-dimensional array is actually a sum of the white tiles that are still visible after processing the list in a segment of it.

ChatGPT interaction - How did interactions with ChatGPT assist in understanding or solving this problem?

[12:28 PM, 10/24/2023] Daniel Gil: How did interactions with ChatGPT assist in understanding or solving this problem? I have this very common pattern that I usually don't do right away, obviously, as I confront the problem, even if I just confront it with the purposes like reviewing its theory, where I don't try to solve it, but just to understand the problem statement, the examples, maybe test a couple assumptions really quickly, but most of the time what I do in those sessions is that I literally ask ChatGPT what a tag is about, so that's a very common pattern. Like I have a question with tag X, what's that? That's the prompt that I use to ask ChatGPT about a specific topic, and it works kind of well to give like a general high-level overview of it, and a lot of times it goes ahead and gives you like the most common basic level problem that you can understand a little bit of the concept with at the beginning. The second common pattern that is the one that I ended up using here is directly when working with solutions, when a particular solution seems tricky, in particular the explanation, and on LeetCode it happens a lot that there's this user called Lee215, I think it's Chinese, I heard someone comment one time that he has a YouTube channel where he explains and has tutorials about things, but it's in Chinese, and so sometimes his English is kind of difficult to understand because the conjugation and stuff of the verse and grammatically is a little bit inappropriate, but he's spot on, right, and so it's easier as his patterns, I guess his patterns of communication are common mistakes for English as a second language learner from China directly, if Chinese is your native language, and so it is able to like elaborate on the explanations that that particular user has, and a lot of other users like from India and etc., and in general people that are not very good at explaining themselves, and so this basically elaborates on those solutions, gives nuance details, and the pattern that I have is basically I copy the problem statement fully together with examples and constraints, and then I copy right beneath it the explanation and code, literally the post with the solution that the user had, and ask for explanations on it. I have found that that works better than asking ChagGPT directly for a solution from the problem statement because a lot of times if the problem is weird or a little bit twisted in a novel way that ChagGPT might have not experienced in the past, it can hallucinate like crazy, and a lot of times it doesn't give you the most optimal solution, even if it is correct, so you still need humans for that, particularly that probably like 1% humans are best at code that you're trying to emulate and learn from, and so ChagGPT gives very structured explanations. I also have kind of like a little custom instructions that I guess I'll be sharing that I provide to it, so it more or less has some guidelines on the type of answer that I'd like to receive, and I think it probably formats things in this manner anyway, so it depends on the thing that I asked it, in this case I asked it, can you help me understand this problem's code solution, and a little bit on the logic behind it, so I was specifically targeting the code part of it, which is important because if I just tell it can you help me understand this, it's going to assume that I'm asking about understanding even the problem statement, which I didn't have the problem with this time, so you have to be careful in how you prompt it for it to be useful, and the little bit on the logic behind it was because I didn't feel fully clear still on the high level description of what the solution to the problem was, and so what I get from that is basically an explanation that is like highly surrounded by the literal variables and functions and part of the code that the user for Solving actually used, so that's kind of helpful, I used that. Then there was another type of solution, I wanted to ask for clarification if the approach was bottom up or top down, and that's like a concept of dynamic programming, I also asked about, I wanted to understand like when to use dynamic programming, and I wanted to proceed to ask more questions, but I basically ran out of time, and that's another interesting prompt that I usually ask GPT for, but yeah, I basically used it to elaborate on concepts related to dynamic programming because I wanted to learn more in depth about a few of the terms that other users were talking about, make part of their decision and their solution, and I wanted to understand explicitly another solution that used like iteration, and the DP without cache, which was what the original super succinct solution from Lee 215 used, and yeah, that's basically what I used GPT for.

Discoveries - Did you have any insights or moments of realization while working on this problem?

[12:32 PM, 10/24/2023] Daniel Gil: Do you have any insights or moments of realization while working on this problem? Yes. I mean, since the beginning I was thinking that maybe the problem had something to do with like a sliding window kind of thing. I was thinking if the total number of those sub-sequences of the initial string was like a combination. No, because it actually has to be inside the sequence, so that limits the possibilities for how many places to place each one of the carpets in. So there's not a big search space for one single carpet, and you can think of it as a sliding window. So I guess that gave me insight about the fact that you can choose to place or not place a carpet on one tile. And not precisely place the carpet, but start the placement of the carpet at that particular index, because a carpet can occupy several indexes. So that gave me insight into that, but I followed it to the wrong route, because it basically made me think that a video approach was appropriate. And actually on discussion, I found a very explicit corner example of that. But I actually also kind of discovered myself in isolation. And so I discovered that the search space was probably bigger than that, and there were more possibilities. And I think there was another set of smaller discoveries or moments of understanding while I worked on the solution that these guys had. I particularly enjoyed the second solution, because it's more like in-depth. The first solution from Lee215 in Python is particularly short and uses a lot of features from Python that would make it kind of so annoying, because it's not super pure programming-wise. But it's kind of cool that it's super short, the solution, anyway.

Tricky parts - Were there specific elements or constraints in the problem that seemed tricky or noteworthy?

[12:34 PM, 10/24/2023] Daniel Gil: Were there specific elements or constraints in the problem that seemed tricky or noteworthy? Yes, I didn't know the manner in which I should traverse the space of available combinations of carpet placement. It was kind of difficult to picture, for once. And for starters, I know, and it has been my experience, that dynamic programming questions are always kind of tricky. And I still find it super unintuitive to come up with solutions to questions like this, or for it to come to my head that dynamic programming is a solution for one of these things. So I think that was kind of tricky. Were there any constraints in the code? No, I think it was very straightforward. The number of carpets was a thousand. That was pretty much understandable. But yeah, the dynamic programming approach and the optimal substructure of the problem, so that you can find the minimum if you find the minimum in sub-sequences of the first sequence, is kind of tricky, particularly to picture all of that in your head. But I guess with learning about the concepts and getting a closer look into things, you can, with time, start working on it. I still don't feel super strong on this one, and I didn't mark it as understood, still.

Solution - Can you break down your solution's code? What is the role of each significant section or function?

[1:53 PM, 10/24/2023] Daniel Gil: Can you break down your solution's code? What is the role of each significant section or function? For this, it's kind of complicated, well, not so much. On the high level, you can think of it as we're basically considering all the possibilities at each step when the choice that we can make at each step is either placing a carpet at such index, or starting at that index, or not placing it, right? And so as we are optimizing to find the, you know, given the problem statement, the minimum number of white tiles still visible at the end, at each step, we do the same. That's why the substructure of the problem is optimal, I think, because, you know, if I find the minimum in shorter segments of the original string, and if I sum up those steps, at the end I'm going to have the minimum across the whole string, right? And so to find the minimum, there is among two choices. We basically pick what is best, what is most efficient. Not placing the carpet or placing it? Not placing the carpet implies that we have to take into account the sum of one if there is a white tile that is going to end up being visible, so we have to count it if we don't place the carpet, right? And then we have to sum that with whatever carpets are in the rest of the decisions. And so we call, again, dp, but on the next index. And we're going from index length of floor, or index n, or basically we go from the right, far right of the string toward the left, at least in the order, not in the order, but in the, yeah, in the manner in which the function calls that we make in this solution are going to be placed on the stack. The other second option is to actually place a carpet which would occupy whatever the length of the carpet is in indexes. So the next dp we're going to call in that case is going to be current index minus, not one to the next, but i, the current index, minus the length of the carpets that the problem gives us. And so we effectively move until the other extreme of the carpet, continuing all places we can actually place carpets onto, and we effectively also reduce k, which is the value of carpets left to place, by one, because we just placed one. If k is zero, so we have already placed all the carpets, we return a thousand on the right side of the min, which given that it is the maximum number of carpets that there could be, ultimately what it means is that when we don't have any more carpets, we have to count the visible white, if there is at this index. So we go to the right side, and we move to the next index, one place next to it. And so the dp starts with receiving an index, the index is for the place that we're going to be thinking about, and a number of carpets.


Optimization - Did you identify potential areas for optimization in your solution?


[2:06 PM, 10/24/2023] Daniel Gil: Optimization. Did you identify potential areas for optimization in the solution? Well, it was hard to understand what the complexity of each one of the solutions was to begin with. I guess if you end up doing the tabulation thing with dynamic programming, it seems that you end up registering k states of the count for each one of the indexes or tiles. So basically you have, and k corresponds to the carpets, the number of carpets. So you basically have what happened at this index after placing x carpets. And x goes through 0 all the way to k, the number of carpets. And the indexes go from 0 to n, n being the length of the initial input string. So we basically have n times c states. Or so problems can be called. This is probably the hardest question that I've confronted in this article manner, so I have still a lot of questions about it. But I was chatting with GPT, and for me it was kind of stupid that you can even have or even care about collecting a state such as an index 0 having placed, let's say, 1,000 carpets. Because if you're at 0 and you place 1,000 carpets, I mean, if you're in the same spot, placing the second carpet makes no sense, right? And the third and the fourth and the 1,000 on top of each other is like, why would I care about computing that kind of thing? And in fact, why would I care about placing one carpet exactly on top of the previous one at all? Does that even happen in the code? I still have so many questions, dude.

[2:29 PM, 10/24/2023] Daniel Gil: Did you identify potential areas for optimization in your solution? I mean, just understanding the complexity of the thing that I guess is given for the amount of calculations that are done, which could be optimized for some kind of stupid states that the actual code considers, because it's basically for the N tiles, considering what would happen at each tile having placed 0, 1, 2, 3, all the way to K, K being the number of carpets, which basically gives N times C. But there are some stupid cases like why would you consider placing K carpets one on top of each other on the first case, on the first tile? I mean, it's just repeating the same thing. So I guess that's where they open space for further optimizing and making space be less than that. And I don't know if time complexity also. But in general, or in any case, it is still kind of confusing. I think this is the first problem that makes me question the nature of these articles that I'm trying to write, because I can't do for the time being unless I decide to waste more time. And my experience has been that the quicker I move away from problems that I'm frustrated or stuck in, the better and stronger I come later at confronting them, when confronting them again. So I'll move forward and confirm with this that the nature of these articles is documenting my process. This is super difficult to understand.

Learned - How does this problem fit into broader concepts within data structures, algorithms, or computer science?

[2:32 PM, 10/24/2023] Daniel Gil: How does this problem fit into broader concepts within data structures, algorithms, or computer science? I guess the dynamic programming is super fundamental, the stuff related to it. I guess this time I got into understanding a little bit of this, maybe to an intermediate level of depth, on the recursiveness and the nature of that tabulation or memoization kind of thing, and also the way you can implement that same thing with iteration, which conceptually is just making tables, tabulation, right, for keeping the state of things. I also understood a little bit more in handy the thing about optimally solving problems and how a bigger problem that is constructed with optimal solutions to smaller problems, one, can be solved with dynamic programming, and two, that kind of structure is the optimal for dynamic programming, right? We discovered that a greedy kind of approach or algorithm can not hold in smaller solutions of things, for which proceeds that a dynamic programming solution for, I mean, from which it follows that greed is not the approach and is rather a perfect kind of problem to solve with dynamic programming. I think that's kind of what I understood. 


Further - Are there any resources, readings, or tools that you found particularly helpful or 
enlightening for this problem?


Further, are there any resources, readings, or tools that you found particularly helpful or enlightening to this problem? I guess two solutions that I evaluated. I checked the hints and lit code a little bit, and the conversation that I had with Chad Dubity that I was due to expand on, but I'm not tempted to use more of my time stuck understanding at a low level this question. I can give it a little bit of a break before delving more into these topics, but it's clear that dynamic programming is one of those topics that I have to pay more attention to because it is still challenging.
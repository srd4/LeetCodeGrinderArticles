
## Initial thoughts.
What methods or algorithms came to mind when you first approached this problem?

I remember at the beginning of starting to confront LeetCode problems I made these judgments based on my ability that something was more difficult than it seemed. And problems with diagrams like this, I'd go "Jesus Christ" a lot of times. But once you get pass that and actually judge a problem by what it really is, you are going to discover a lot of verbose problems being actually quite simple, and a lot others being the totally opposite lol.

The context in which the problem is discussed is basically graphs. They talk about edges and vertices.

I noticed early on that you are able to visualize this like a binary string, where each position in the string can take either a 1 or a 0. The monkeys can each one make one movement. They can go left, or right or we can think of it as they can go 1 or they can go 0. There has to be one decision for each monkey. So the absolute possible total of combinations of monkey movements in a n-vertex polygon will be the total combinations that you get with n positions in the binary string.

Because there are n positions and each one of the positions can take two values, either a 1 or a 0 you basically have 2<sup>n</sup> combinations.

Now the problem becomes (which was actually the only hint this problem had) counting the combinations that don't produce collisions in order to subtract it from that value of total possible combinations of movements which I know to be 2<sup>n</sup>.

## Past experiences.
Are there related problems or topics you've encountered that share similarities with this one?

Vertices and edges are basic nomenclature that you deal with on problems that make use of graphs of any kind. But I could also, interestingly enough, relate this to even elementary level mathematics or geometry, where they talk about vertices and edges. Everything goes full circle one way or another.

There are a lot of problems that make you think about edges and vertices. I remember a lot of times being confused of what they meant by vertices and edges and kind of like mistaking one for the other. But now it's quite faster to understand what people are talking about in my head while I read. I guess the reading comprehension in regards to that kind of context and vocabulary has improved in me. 

And yeah, there's a lot of problems about that. So if at the beginning you feel kind of slow with them or their nomenclature, keep grinding, is not that they get easier, but you actually get harder.

There are also a lot of problems about basically having to surround or enumerate possibilities. Actually, there's a literal enumeration tag where you have to discover and list each one of the edge cases that you discover for the problem and decide how to handle them explicitly.

In this case it is kind of like that because you have to discover that each monkey can move one direction or the other in one step. They can't go any further. So those options of movements are the cases that we enumerate, account for and handle in our code. Then we have to think about the possible combinations of that.

If there's not only one monkey, but it's two monkeys or three monkeys or four. And the number of monkeys depends on the number of vertices in the polygon, and such number having each the ability to make one decision or another make a set of combinations of final decisions accounting for what each monkey chose.

So, in summary, confronting LeetCode I've found, problems about both graphs, and things that have to do with enumeration and like literally and explicitly with binary stuff, binary strings and bit manipulation, that's another common one. The first even if it's just geometric problems that are easy like this or complex problems that you still have to abstractly think about graphs and edges while working with arrays. And the second for an actual wide range of use cases.

ChatGPT interaction
How did interactions with ChatGPT assist in understanding or solving this problem?

I didn't use 


Discoveries.
Did you have any insights or moments of realization while working on this problem?

Tricky parts
Were there specific elements or constraints in the problem that seemed tricky or noteworthy?

Solution
Can you break down your solution's code? What is the role of each significant section or function?

Optimization
Did you identify potential areas for optimization in your solution?

What I learned
How does this problem fit into broader concepts within data structures, algorithms, or computer science?

Further learning
Are there any resources, readings, or tools that you found particularly helpful or enlightening for this problem?